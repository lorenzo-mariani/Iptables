## Why analyze firewall logs?

Firewalls are inline devices and are therefore well positioned to apply filtering logic to network traffic. An *inline device* is any piece of hardware that lies in the direct path of packets as they are routed through a network. If a hardware or software failure develops within an inline device and affects its ability to forward network traffic, network communications cease to function. Example inline devices include routers, switches, bridges, firewalls, and network intrusion prevention systems (IPSs). As firewalls become more full featured and complex, they are gradually offering capabilities (such as application layer inspection) that have traditionally been the purview of intrusion detection systems. By combining these features with the ability to filter traffic, firewalls can provide valuable intrusion detection data that can offer an effective mechanism to both protect services from outright compromise and sophisticated reconnaissance efforts, and limit the potential damage from worm traffic. Firewalls like iptables that offer extensive logging and filtering capabilities can provide valuable security data that should not be ignored. While a dedicated intrusion detection system such as Snort offers a large feature set and a comprehensive rules language to describe network attacks, iptables is always inline to network traffic and offers detailed packet header logs.

## Psad features

Psad can detect various types of suspicious traffic, such as port scans generated by tools like Nmap, probes for various backdoor programs, Distributed Denial of Service (DDoS) tools, and efforts to abuse networking protocols. When combined with fwsnort, psad can detect and generate alerts for over 60 percent of all Snort-2.3.3 rules, including those that require the inspection of application layer data. Among psad’s more interesting features is its ability to passively fingerprint the remote operating system from which a scan or other malicious traffic originates. For example, if someone launches a *TCP connect()* scan from a Windows machine, psad can (usually) tell whether the scan came from a Windows XP, 2000, or NT machine. Furthermore, psad also offers verbose email and syslog alerts, the ability to automatically block an IP based on a danger level threshold (this feature is disabled by default), integrated whois support, DShield reporting, and more.

## Psad administration

#### Starting and stopping psad

When psad is started via the init script, 3 daemons are also started: *the main psad daemon*, *kmsgsd*, and *psadwatchd*. The purpose of *kmsgsd* is to read all iptables log messages out of the */var/lib/psad/psadfifo* named pipe and write them to a separate file, */var/log/psad/fwdata*, for on-the-fly analysis by psad. In this way, psad is supplied with a pure data stream that exclusively contains iptables log messages. The *psadwatchd* daemon simply makes sure that both the *psad* and *kmsgsd* daemons are running and restarts them if they are not. If *psadwatchd* must restart either of the other two daemons, it sends a warning email to the email address listed within the */etc/psad/psad.conf* file.

#### Daemon process uniqueness

When psad is started, each of the 3 psad daemons writes its own process ID (PID) to files within */var/run/psad*. If any daemon is started manually from the command line, it first checks to see if another instance is running; if so, the new instance exits immediately. This ensures any existing psad process is left undisturbed.

#### Iptables policy configuration

Fundamentally, psad is a log analyzer. It assumes that the iptables policy on the system where psad is deployed is configured in a log-and-drop stance. This ensures that iptables only accepts those packets that are strictly necessary for the network to function; all other packets are logged and dropped. Port scans, probes for backdoor programs, subversive application commands, and other nefarious miscellany lie outside the list of acceptable network traffic, so iptables logs derived from such a policy can commonly provide a valuable supplement to a dedicated intrusion detection system. An automated mechanism for verifying that the local iptables policy is configured with default LOG and DROP rules in both the INPUT and FORWARD chains is provided by psad. This mechanism is a dedicated script located at */usr/sbin/fwcheck_psad*, which is executed by psad at start time (unless the *--no-fwcheck* command-line switch is given or psad is running on a separate syslog server). The *fwcheck_psad* script uses the *IPTables::Parse* Perl module to acquire a representation of the local iptables policy, which it interprets to see if it contains the LOG and DROP rules. If not, psad will send a configuration alert email to inform you that the iptables policy is not properly configured.

#### Syslog configuration

When a packet is matched by a LOG rule within iptables, the kernel reports this fact via *klogd*, the kernel logging daemon. The resulting kernel log message is then normally passed on to syslog for eventual reporting to a file, to a named pipe, or even to an entirely separate system via the Berkeley sockets interface. This all depends on the set of features offered by the syslog daemon and how its configuration is set up. The *syslogd* and *syslog-ng* daemons are compatible with psad, and psad also has some limited support for metalog. Both *syslogd* and *syslog-ng* can write log messages to named pipes; psad takes advantage of this by configuring all *kern.info* log messages to be written to the */var/lib/psad/psadfifo* named pipe, where they are then picked up by *kmsgsd*. When *kmsgsd* receives a syslog message via the *psadfifo*, it checks to see if the message contains two substrings (IN= and OUT=) to ensure that the syslog message is generated by iptables. If the message passes this test, *kmsgsd* appends it to the file */var/log/psad/fwdata* so that it will be seen by psad. After all, many *kern.info* syslog messages could be generated by portions of the kernel that have nothing to do with iptables; *kmsgsd* ensures that only iptables messages are subsequently analyzed by psad.

NOTE: The IN= and OUT= strings denote the input and output interfaces associated with a packet that has been logged via the iptables LOG target. These strings are always included in iptables log messages.

#### Syslogd

If psad is running on a system with *syslogd* installed, the following line is appended to the */etc/syslog.conf* configuration file at install time; it figures syslogd to write *kern.info* messages to *var/lib/psad/psadfifo*:

	kern.info               |/var/lib/psad/psadfifo

#### Syslog-ng

If, on the other hand, *syslog-ng* is the syslog daemon of choice on the local system, then the following lines are appended to the */etc/syslog-ng/syslog-ng.conf* configuration file at install time. (A check is performed to ensure that the logging source *psadsrc* is defined earlier in the *syslog-ng.conf* file and that it points to */proc/kmsg*.)

	source psadsrc { unix-stream("/dev/log"); internal(); pipe("/proc/kmsg"); };
	filter f_psad { facility(kern) and match("IN=") and match("OUT="); };
	destination psadpipe { pipe("/var/lib/psad/psadfifo"); };
	log { source(psadsrc); filter(f_psad); destination(psadpipe); };

#### Whois client

An excellent *whois* client is bundled with the psad sources. This client almost always queries the correct netblock for a given IP address, and psad leverages the client to query IP address ownership information and include it within email alerts (unless the *--no-whois* command-line switch is given). Having such information simplifies the process of identifying the administrator of the network from which a scan or other attack is detected.

NOTE: *whois* client is installed at */usr/bin/whois_psad*, so as not to overwritw any existing *whois* client on the system. 

## Psad configuration

All psad daemons reference the file *psad.conf* within */etc/psad*, and this file follows a simple convention where comment lines begin with a hash (#) mark, and configuration parameters are specified in a key-value format. For example, the HOSTNAME variable in *psad.conf* defines the hostname of the system where psad is deployed:

	### System hostname
	HOSTNAME                psad.cipherdyne.org;

Each value for a configuration variable must be terminated with a semicolon to denote the end of the value string. This allows comments to be included on the same line after the semicolon to aid in documentation, as in this example:

	WHOIS_TIMEOUT               60;  ### seconds

Finally, psad variable values may contain subvariables that are expanded as psad parses its configuration. For example, the main logging directory used by psad is defined by the PSAD_DIR variable and is set to */var/log/psad* by default. Other configuration variables can reference the PSAD_DIR variable like so:

	STATUS_OUTPUT_FILE          $PSAD_DIR/status.out;

#### /etc/psad/psad.conf

The *psad.conf* file is psad’s main configuration file. It contains well over 100 configuration variables to control various aspects of psad’s operations. We’ll discuss a few of the more important configuration variables and the reasons they are significant.

Variables | Used for |
--- |
EMAIL_ADDRESSES | Defines the email address(es) to which psad sends scan alerts, informational messages, and other notices. Multiple email addresses are supported as a comma-separated list
DANGER_LEVEL{n} | All malicious activity is associated with a danger level by psad so that alerts can be prioritized. Danger levels range from 1 to 5 (with 5 being the worst) and are assigned to each IP address from which an attack or scan is detected. The danger level values are assigned based on 3 factors: characteristics of a scan (number of packets, port range, and time interval), whether a specific packet is associated with a signature defined in the */etc/psad/signatures* file, and whether the packet originates from an IP or network listed in the */etc/psad/auto_dl* file. For port scans and corresponding packet counts, the DANGER_LEVEL{n} variables in the *psad.conf* file specify the number of packets required to reach each successive danger level
HOME_NET | Defines the local network where the system running psad is deployed
EXTERNAL_NET | Defines the set of external networks. The default value is any, but it can be set to an arbitrary list of networks, similar to the HOME_NET variable
SYSLOG_DAEMON | Tells psad which syslog daemon is running on the local system. Possible values for this variable are: *syslogd, syslog-ng, ulogd, and metalog*. This variable allows psad to verify that the corresponding syslog configuration file is set up properly so that *kern.info* messages are written to the */var/lib/psad/psadfifo* named pipe, with one exception: if psad is configured to acquire iptables log messages via *ulogd*, no syslog daemon is required to be running, because messages are written to disk directly by *ulogd*. The *kmsgsd* daemon is not even started by psad in this situation.
CHECK_INTERVAL | Most of psad’s time is spent sleeping; it only wakes up to see if new iptables log messages have appeared in the */var/log/psad/fwdata* file. The time interval between successive checks is defined in seconds by the CHECK_INTERVAL variable; the default is 5 seconds. This interval can be set as low as 1 second, but it is not usually necessary to do so unless you want alerts to be generated as quickly as possible
SCAN_TIMEOUT | By default, the SCAN_TIMEOUT variable is set to 3,600 seconds (one hour), and psad uses this value as the time interval over which a scan is tracked. That is, if malicious traffic from a particular IP address does not reach a danger level of one within this time period, psad will not generate an alert. The SCAN_TIMEOUT variable can effectively be ignored by setting ENABLE_PERSISTENCE to Y
ENABLE_PERSISTANCE | Port scan detection software generally must set 2 thresholds in order to catch a port scan: the number of ports probed and the time interval. An attacker can attempt to slip beneath these thresholds by either reducing the number of scanned ports or slowing down the scan. The ENABLE_PERSISTENCE variable instructs psad not to use the SCAN_TIMEOUT variable as a factor in scan detection. This is useful to thwart attempts by a scanner to slip beneath the timeout threshold by slowly scanning a target system over days or weeks. As soon as a scan involves at least the number of packets defined by the DANGER_LEVEL1 variable (regardless of how long the scan takes to send this number of packets), an alert is sent by psad. 
PORT_RANGE_SCAN_THRESHOLD | This variable allows you to define the minimum range of ports that must be scanned before psad will assign a danger level to a port scan. By default, PORT_RANGE_SCAN_THRESHOLD is set to one, which means that at least two different ports must be scanned before a danger level of one is reached. In other words, an IP address could repeatedly scan a single port and psad would never send an alert. you don’t want psad to factor in the range of scanned ports at all, then set PORT_RANGE_SCAN_THRESHOLD to zero
EMAIL_ALERT_DANGER_LEVEL | This variable allows you to set a minimum on the danger level value so that psad will not send any email alerts unless an IP address has been assigned a danger level that is at least equal to this value. The default setting is one
MIN_DANGER_LEVEL | The MIN_DANGER_LEVEL threshold acts as a global threshold for all alerting and tracking functions performed by psad. If MIN_DANGER_LEVEL is set to two, for example, then psad will not even write an IP address to the */var/log/psad/ip* directory until it reaches a danger level of two. Therefore, the MIN_DANGER_LEVEL variable should always be less than or equal to the value assigned to the EMAIL_ALERT_DANGER_LEVEL variable above. The default MIN_DANGER_LEVEL is one
SHOW_ALL_SIGNATURES | This variable controls whether or not psad includes all signature alert information associated with an IP address in every alert. It is disabled by default because it can result in lengthy email alerts from psad if a particular IP address is consistently hitting your site with suspicious traffic over long periods of time. However, psad email alerts will include all newly triggered signatures in the last CHECK_INTERVAL, even when SHOW_ALL_SIGNATURES is disabled
ALERT_ALL | When set to Y, this variable instructs psad to generate email and/or syslog alerts whenever new malicious activity is seen from an IP address, as long as a danger level of one has been reached. If set to N, psad will only generate alerts when the danger level associated with an IP address increases
SNORT_SID_STR | This variable defines a substring to match against iptables log messages to see if any of the messages were generated by an iptables rule that completely characterizes a Snort rule. Such iptables rules are produced by fwsnort, and they generally contain a logging prefix of SID{n}, where {n} is the Snort ID number derived from the original Snort rule. The default value for SNORT_SID_STR is just SID
ENABLE_AUTO_IDS | If set to Y, this variable transforms psad from a passively monitoring daemon into a program that actively responds to attacks by dynamically reconfiguring the local iptables policy to block an offending IP address from interacting with the local system (via the INPUT and OUTPUT chains) and with all systems that may be protected by the local system (via the FORWARD chain)
IMPORT_OLD_SCANS | The information that psad collects about port scans and other suspicious activities is written to the */var/log/psad* directory. For every IP address that reaches a danger level of one, a new directory */var/log/psad/ip* is created. Various files stored within this directory include the latest email alert, whois output, signature matches, danger level, and packet counters. At start time, psad normally removes any existing */var/log/psad/ip* directories, but you can have psad import all data from these old directories by setting IMPORT_OLD_SCANS to Y. This feature allows you to restart psad or to reboot the entire system without losing scan data from the previous psad instance
ENABLE_DSHIELDS_ALERTS | Set this variable to Y to allow psad to send scan data to the DShield distributed intrusion detection system. Since scan information can be sensitive, you should be aware that when you pass your scan data to DShield, it is no longer in your control and is parsed into a relatively open database. However, DShield allows people to gain a better understanding of things such as the most commonly attacked services and even which IP address is currently attacking the most systems (making that IP address a good candidate for fairly draconian firewall rules)
IGNORE_PORTS | Instructs psad to ignore iptables log messages based on the destination port number and associated protocol (TCP or UDP). Rather than using the IGNORE_PORTS variable, you could tune your iptables policy so that packets to ports you want to ignore are matched by a rule before they hit the LOG rule
IGNORE_PROTOCOLS | With the IGNORE_PROTOCOLS variable, psad can be instructed to ignore entire protocols
IGNORE_LOG_PREFIXES | If you want psad to ignore a certain logging prefix (e.g., DROP:INPUT5:eth1)
EMAL_LIMIT | In some circumstances an iptables policy is configured to log certain traffic that is not malicious, and this traffic may repeat over and over again on a network (for example, DNS requests to a specific DNS server). If psad interprets such traffic as a scan, then psad may send a lot of email alerts for the traffic because it repeats itself. You can force psad to impose a limit on the number of email alerts that are sent for any scanning IP address by using the EMAIL_LIMIT variable. The default is zero, which means that no limit is imposed
ALERTING_METHODS | Most administrators use both the email and syslog reporting modes offered by psad, but the ALERTING_METHODS variable gives you control over whether psad generates email or syslog alerts. The ALERTING_METHODS variable accepts three values: *noemail, nosyslog,* and *ALL*. The *noemail* and *nosyslog* values instruct psad to send no email or no syslog alerts; these values can be combined to disable all alerting. The default is to generate both email and syslog alerts
FW_MSG_SEARCH | Defines how psad searches iptables log messages. To restrict psad to analyze only those log messages that contain a specific log prefix (defined in an iptables LOG rule with the *--log-prefix* argument to iptables), define the prefix with the FW_MSG_SEARCH variable. This allows iptables to be configured to assign other log prefixes to packets without having psad analyze them

#### /etc/psad/auto_dl

As with any IDS, there is always a high probability of false positives. Hence, every IDS should be equipped with a whitelisting capability by which certain systems, networks, ports, or protocols can be excluded from any detection mechanism and (most importantly) any automated response features. Because certain IP addresses or networks may be known bad actors, there should also be a provision to blacklist them. These requirements are met in psad’s *auto_dl* file, which follows this syntax:

	ip/network     danger level     optional protocol/optional ports

If the danger level is set to zero, psad will completely ignore the IP address or network. However, the danger level can be set as high as five if a particular IP address or network is known to be extremely malicious. For example, the first of the following two lines ensures that psad will ignore all traffic from the IP address 192.168.10.3; the second line immediately escalates all TCP port 22 (SSH) traffic to a danger level of five from the 10.10.1.0/24 network:

	192.168.10.3     0;
	10.10.1.0/24     5     tcp/22;

#### /etc/psad/signatures

The */etc/psad/signatures* file contains a set of about 200 slightly modified Snort rules. These rules represent attacks that psad is able to detect directly from iptables log messages. None of these rules require application layer tests against network traffic — *fwsnort* runs application layer tests. An example rule from this file is the following:

	alert udp $EXTERNAL_NET any -> $HOME_NET 1026:1029 (msg:"MISC Windows popup
	spam attempt"; classtype:misc-activity; reference:url,www.linklogger.com/
	UDP1026.htm; psad_dsize:>100; psad_id:100196; psad_dl:2;)

The fields *psad_size*, *psad_id*, *psad_dl* above are custom fields added to the Snort rules language by psad. In this case, the *psad_dsize* field requires the data portion of the UDP packet to be larger than 100 bytes, the *psad_id* field defines a unique ID for this rule, and the *psad_dl* field tells psad to assign a danger level of two to any IP address that triggers this signature.

#### /etc/psad/snort_rule-dl

Similarly to the */etc/psad/auto_dl* file, the *snort_rule_dl* file instructs psad to automatically set the danger level of any IP address that triggers a Snort rule match. The syntax of this file is the following:

	sid         danger level

If the danger level is zero, psad ignores the signature match altogether and no alerts are sent. Some signature matches are worse than others, though — if psad detects traffic that matches Snort rule ID 1812 (EXPLOIT gobbles SSH exploit attempt), this is potentially far more damaging than a match for Snort rule ID 469 (ICMP PING NMAP). Of course, the best strategy for limiting the effects of the Gobbles SSH exploit is not to run a vulnerable SSH daemon in the first place, but it is still important to detect attacks for this exploit. You can elevate the danger level of an IP address that matched Snort rule 1812 to 5, like so:

	1812     5;

#### /etc/psad/ip_options

Tthe options portion of the IP header is not often used in IP communications, but iptables can log IP options with the *--log-ip-options* command-line argument. If an iptables log message contains IP options, psad parses these options for suspicious activity, such as source routing attempts. A few Snort rules define suspicious usages of IP options, and psad references the /etc/psad/ip_options file in order to decode IP options in iptables log messages. This file defines commonly used IP options and their corresponding identifying numbers, according to the following syntax:

	option value   length (-1 for variable)   ipopts argument   description

For example, this is how the Snort *lsrr (Loose Source Route)* option is included:

	131  -1  lsrr        Loose Source Route

#### /etc/psad/pf.os

The OS database from the *p0f* project is used by psad to passively fingerprint remote operating systems. This database is installed by psad as the file */etc/psad/pf.os* and is imported at psad startup (or when psad receives a *hangup* or *HUP* signal via the *kill* command or from *psad -H*). Here is an example of a *p0f* fingerprint for Linux:

	S4:64:1:60:M*,S,T,N,W0:         Linux:2.4::Linux 2.4/2.6 <= 2.6.7

## Port scan detection with psad

#### TCP connect() scan

	[ext_scanner]$  nmap -sT -n 71.157.X.X –-max-rtt-timeout 500

	Starting Nmap 4.01 ( http://www.insecure.org/nmap/ ) at 2007-07-08 23:22 EST
	Interesting ports on 71.157.X.X:(The 1671 ports scanned but not shown below are in state: filtered)
	PORT   STATE SERVIC
	80/tcp open  http

	Nmap finished: 1 IP address (1 host up) scanned in 22.551 seconds

A total of 1671 TCP ports were scanned, and nearly all are being filtered as expected because iptables is dropping the majority of the connection attempts. Only the HTTP port is open. Once the scan is finished, we examine the */var/log/messages* file to see if psad has detected the scan. Indeed, the following syslog message appears there:

	Jul  8 23:22:29 iptablesfw psad: scan detected: 144.202.X.X -> 71.157.X.X tcp: [1-65301] flags: SYN tcp pkts: 1532 DL: 4

The psad syslog message shows the source and destination IP addresses, the range of TCP ports that were scanned (1-65301), the flags that were sent (SYN in this case), the total number of packets sent, and the danger level that psad has assigned to the scanner (DL: 4).

In this case, the number of packets monitored by psad is 1532 and this exceeds the 1,500 packets required to reach danger level 4 (as defined by the DANGER_LEVEL4 variable in */etc/psad/psad.conf*). Email alerts are also generated by psad, and they contain a lot more information than can be packed into a single-line syslog message.

To see the iptables log messages that psad used to detect the scan, examine the */var/log/psad/fwdata* file. Here are three log messages from the *fwdata* file:

	Jul  8 23:22:04 iptablesfw kernel: DROP IN=eth0 OUT= MAC=00:13:d3:38:b6:e4:00:30:48:80:4e:37:08:00 SRC=144.202.X.X DST=71.157.X.X LEN=60 TOS=0x00
	PREC=0x00 TTL=64 ID=28124 DF PROTO=TCP SPT=55103 DPT=53 WINDOW=5840 RES=0x00 SYN URGP=0 OPT (020405B40402080A31CAD9280000000001030306)

	Jul  8 23:22:04 iptablesfw kernel: DROP IN=eth0 OUT= MAC=00:13:d3:38:b6:e4:00:30:48:80:4e:37:08:00 SRC=144.202.X.X DST=71.157.X.X LEN=60 TOS=0x00
	PREC=0x00 TTL=64 ID=53661 DF PROTO=TCP SPT=59480 DPT=256 WINDOW=5840 RES=0x00 SYN URGP=0 OPT (020405B40402080A31CAD9280000000001030306)

	Jul  8 23:22:04 iptablesfw kernel: DROP IN=eth0 OUT= MAC=00:13:d3:38:b6:e4:00:30:48:80:4e:37:08:00 SRC=144.202.X.X DST=71.157.X.X LEN=60 TOS=0x00
	PREC=0x00 TTL=64 ID=36136 DF PROTO=TCP SPT=60134 DPT=3389 WINDOW=5840 RES=0x00 SYN URGP=0 OPT (020405B40402080A31CAD9280000000001030306)

The field OUT above shows that the output interface is blank. This tells us that either the packet that generated the log message hits a LOG rule from within the iptables INPUT chain, or it hits a LOG rule in a chain before the routing calculation is made within the kernel (e.g., the PREROUTING chain in the raw table). Because the iptables logging format does not explicitly include the iptables chain that contains the LOG rule, we can’t tell from the log message above whether the packet is logged from the INPUT chain or the PREROUTING chain. However, because it’s likely that more iptables policies put default LOG rules within the INPUT, FORWARD, or OUTPUT chains than in the PREROUTING or POSTROUTING chains, psad assumes that the following rules apply to all iptables log messages:

* Messages that don’t contain an output interface are logged within the INPUT chain.
* Messages that don’t contain an input interface are logged within the OUTPUT chain.
* Messages that contain both an input and output interface are logged within the FORWARD chain.

Hence, for the TCP *connect()* scan discussed above, psad assumes that the scan is logged via the INPUT chain. Because the source IP address 144.202.X.X is included within the log messages (SRC field), psad knows where the scan originated.

NOTE: Remember that scans are sometimes deliberately spoofed, so this IP address cannot be completely trusted as the real source of the scan. When executed as root, Nmap can send spoofed scans with the decoy option (-D), and the Idle scan uses IP spoofing as an integral component.

Recall that a total of 1,671 ports were scanned by Nmap in the *connect()* scan above, but only 1,532 iptables log messages were written to the */var/log/psad/fwdata* file. The difference stems from two factors: the ability of iptables to quickly generate log messages, and SYN packet retransmissions from Nmap. Because iptables logs internally to a ring buffer within the kernel, if the traffic rate is fast enough to overwrite the ring buffer with new messages before the old ones can be written to the */var/lib/psad/psadfifo* named pipe, then those messages are simply lost.

#### TCP SYN or Half-Open scan

The SYN scan is Nmap’s default scan type when executed by a privileged user.

Because the iptables firewall on the target system has been configured to drop all SYN packets not destined for TCP port 80, the SYN scan looks nearly identical to a regular TCP *connect()* scan when viewed on the wire, because there are very few SYN/ACK packets for the scanners’ TCP stack to respond to. We see SYN packets from the same source address and nothing else.

This reasoning is generally sound in theory, but in practice we see several significant differences between the SYN and *connect()* scans even when the initial SYN packets are dropped by iptables in both cases. These differences show up in the specific packet header fields for the SYN packets that are sent by Nmap in the SYN scan mode versus those that are sent by the TCP stack itself via the Nmap *connect()* scan. Many more TCP options are sent by the *connect()* scan than by the SYN scan, but there are other differences as well.

The command below starts a SYN scan against the target IP address 71.157.X.X:

	[ext_scanner]# nmap -n 71.157.X.X --max-rtt-timeout 500

	Starting Nmap 4.03 ( http://www.insecure.org/nmap/ ) at 2007-07-13 13:58 EDT
	Interesting ports on 71.157.X.X:
	(The 1672 ports scanned but not shown below are in state: filtered)
	PORT   STATE SERVICE
	80/tcp open  http

	Nmap finished: 1 IP address (1 host up) scanned in 22.611 seconds

A quick examination of the */var/log/messages* file shows that psad has detected the scan:

	Jul  13 13:58:10 iptablesfw psad: scan detected: 144.202.X.X -> 71.157.X.Xtcp: [1-65301] flags: SYN tcp pkts: 1542 DL: 4

The scanner has reached danger level 4 because over 1,500 packets have been sent, and this exceeds the DANGER_LEVEL4 variable in the *psad.conf* file. Once again, on the target system, iptables has logged each SYN packet from the scan:

	Jul 13 13:58:04 iptablesfw kernel: DROP IN=eth0 OUT= MAC=00:13:d3:38:b6:e4:00:30:48:80:4e:37:08:00 SRC=144.202.X.X DST=71.157.X.XLEN=44 TOS=0x00 
	PREC=0x00 TTL=53 ID=27267 PROTO=TCP SPT=62316 DPT=7200 WINDOW=2048 RES=0x00 SYN URGP=0 OPT (020405B4)

	Jul 13 13:58:04 iptablesfw kernel: DROP IN=eth0 OUT= MAC=00:13:d3:38:b6:e4:00:30:48:80:4e:37:08:00 SRC=144.202.X.X DST=71.157.X.XLEN=44 TOS=0x00 
	PREC=0x00 TTL=55 ID=29182 PROTO=TCP SPT=62316 DPT=5001 WINDOW=4096 RES=0x00 SYN URGP=0 OPT (020405B4)

	Jul 13 13:58:04 iptablesfw kernel: DROP IN=eth0 OUT= MAC=00:13:d3:38:b6:e4:00:30:48:80:4e:37:08:00 SRC=144.202.X.X DST=71.157.X.XLEN=44 TOS=0x00 
	PREC=0x00 TTL=59 ID=39294 PROTO=TCP SPT=62315 DPT=3264 WINDOW=4096 RES=0x00 SYN URGP=0 OPT (020405B4)

There are several fields of the iptables log messages above that are different from the TCP *connect()* scan:

* **LEN:** The length field in the IP header is 14 bytes shorter for the SYN scan because the real TCP stack has more options in the SYN packets that it sends via the *connect()* scan.
* **TTL:** The Time-to-Live (TTL) value in the IP header is always initialized to the same value by the real IP stack on a client system during the TCP *connect()* scan. However, because Nmap is crafting the TCP SYN packet in the SYN scan, it can set the TTL value to whatever it wants, and it randomly selects TTL values between 37 and 60.
* **WINDOW:** The TCP window size is set by Nmap to be either 1024, 2048, 3072, or 4096 during the SYN scan. In contrast, the real TCP stack always initiates TCP connections with a window size of 5840.
* **OPTIONS:** The options portion of the TCP header is substantially shorter in the Nmap SYN scan. In this case, it uses a single option, the Maximum Segment Size, and sets it to 1460. Most real TCP stacks send multiple options, such as the Timestamp, No Operation (NOP), and whether Selective Acknowledgment is OK (SACK), in addition to the Maximum Segment Size.

#### TCP FIN, XMAS and NULL scans

The Nmap FIN, XMAS, and NULL scans appear quite similar when represented by iptables log messages. Indeed, the only significant difference between these scan types is the combination of TCP flags used — a difference that shows up in the TCP flags portion of the iptables logging format for TCP packets. In addition, because the FIN, XMAS, and NULL scans are each represented by a specific Snort rule that does not require application layer inspection, psad can detect these scans via individual packets rather than having to rely on packet counts and port ranges.

You can initiate the FIN, XMAS, and NULL scans with the respective *-sF, -sN, and -sX* command-line arguments to Nmap.

	[ext_scanner]# nmap -sF -n 71.157.X.X --max-rtt-timeout 5

	Starting Nmap 4.03 ( http://www.insecure.org/nmap/ ) at 2007-07-13 14:39 EDT
	All 1674 scanned ports on 71.157.X.X are: open|filtered

	Nmap finished: 1 IP address (1 host up) scanned in 36.223 seconds

As you can see, the FIN scan did not escape psad’s watchful eye:

	Jul  13 14:39:10 iptablesfw psad: scan detected: 144.202.X.X -> 71.157.X.X tcp: [1-65295] flags: FIN tcp pkts: 1511 DL: 4

We see many log messages in the */var/log/psad/fwdata* file that resemble the following message. The FIN flag is listed along with the DROP INVALID logging prefix that shows that the INVALID state logging rule matched the packets:

	Jul 13 14:39:05 iptablesfw kernel: DROP INVALID IN=eth0 OUT= MAC=00:13:d3:38:b6:e4:00:30:48:80:4e:37:08:00 SRC=144.202.X.X DST=71.157.X.X LEN=40 TOS=0x00 
	PREC=0x00 TTL=54 ID=7549 PROTO=TCP SPT=45615 DPT=8021 WINDOW=3072 RES=0x00 FIN URGP=0

	Jul 13 14:39:05 iptablesfw kernel: DROP INVALID IN=eth0 OUT= MAC=00:13:d3:38:b6:e4:00:30:48:80:4e:37:08:00 SRC=144.202.X.X DST=71.157.X.X LEN=40 TOS=0x00 
	PREC=0x00 TTL=53 ID=24087 PROTO=TCP SPT=45615 DPT=2431 WINDOW=2048 RES=0x00 FIN URGP=0

	Jul 13 14:39:05 iptablesfw kernel: DROP INVALID IN=eth0 OUT= MAC=00:13:d3:38:b6:e4:00:30:48:80:4e:37:08:00 SRC=144.202.X.X DST=71.157.X.X LEN=40 TOS=0x00 
	PREC=0x00 TTL=53 ID=33917 PROTO=TCP SPT=45615 DPT=377 WINDOW=2048 RES=0x00 FIN URGP=0

XMAS and NULL scans generate iptables log messages that are very similar to those of the FIN scan; an XMAS scan log message just contains URG PSH FIN instead of only the FIN flag:

	Jul 13 14:39:05 iptablesfw kernel: DROP INVALID IN=eth0 OUT= MAC=00:13:d3:38:b6:e4:00:30:48:80:4e:37:08:00 SRC=144.202.X.X DST=71.157.X.X LEN=40 TOS=0x00 
	PREC=0x00 TTL=53 ID=33917 PROTO=TCP SPT=45615 DPT=377 WINDOW=2048 RES=0x00 URG PSH FIN URGP=0

A NULL scan log message contains no TCP flags at all:

	Jul 13 14:39:05 iptablesfw kernel: DROP INVALID IN=eth0 OUT= MAC=00:13:d3:38:b6:e4:00:30:48:80:4e:37:08:00 SRC=144.202.X.X DST=71.157.X.X LEN=40 TOS=0x00 
	PREC=0x00 TTL=53 ID=33917 PROTO=TCP SPT=45615 DPT=377 WINDOW=2048 RES=0x00 URGP=0

#### UDP scan

Scans for UDP services don’t exhibit the same richness as scans for TCP services because UDP is much simpler than TCP and has no parallel notion of a “connection” as does TCP. Fortunately, iptables still lets us track packets that are related to UDP communications, such as the reply from an external DNS server to a DNS query issued by an internal system behind the iptables firewall. This important feature can help us to distinguish legitimate UDP replies from packets that compose a UDP scan. We use the *-sU* option to scan the system running iptables:

	[ext_scanner]# nmap -sU -n 71.157.X.X --max-rtt-timeout 500

	Starting Nmap 4.03 ( http://www.insecure.org/nmap/ ) at 2007-07-13 15:24 EDT
	Interesting ports on 71.157.X.X:
	(The 1481 ports scanned but not shown below are in state: open|filtered)
	PORT   STATE  SERVICE
	53/udp closed domain
	Nmap finished: 1 IP address (1 host up) scanned in 23.721 seconds

The only port that is not in the open or filtered state is UDP port 53. Nmap infers this because it receives an ICMP Port Unreachable message from the target system when UDP port 53 is scanned, and this indicates that there is no server bound to this port. All other probes for the remaining ports are met with complete silence because they are dropped by iptables, so Nmap has no way of knowing whether they are open or filtered. A UDP server is not required to respond in any way to an arbitrary packet, and because the UDP stack itself does not manufacture additional packets (unlike TCP with its acknowledgments and connection shutdown messages), Nmap cannot tell whether there really is a server associated with each of these ports.

When iptables logs a packet, psad assumes that such packets are only logged because they do not conform to the local security policy and may be malicious. So for the UDP scan above, once the number of UDP packets sent by the scanner exceeds the DANGER_LEVEL1 value and the range of scanned ports exceeds the PORT_RANGE_SCAN_THRESHOLD value, psad defines the traffic as a scan. In this example, psad detects the UDP scan and dutifully reports it via syslog:

	Jul 13 15:24:02 iptablesfw psad: scan detected: 144.202.X.X -> 71.157.X.X udp: [2-54321] udp pkts: 922 DL: 3

Here are a few iptables UDP log messages generated by the scan.

	Jul 13 15:24:01 iptablesfw kernel: DROP IN=eth0 OUT= MAC=00:13:d3:38:b6:e4:00:30:48:80:4e:37:08:00 SRC=144.202.X.X DST=71.157.X.X LEN=28 TOS=0x00 PREC=0x00 
	TTL=53 ID=28505 PROTO=UDP SPT=36194 DPT=306LEN=8

	Jul 13 15:24:01 iptablesfw kernel: DROP IN=eth0 OUT= MAC=00:13:d3:38:b6:e4:00:30:48:80:4e:37:08:00 SRC=144.202.X.X DST=71.157.X.X LEN=28 TOS=0x00 PREC=0x00 
	TTL=43 ID=8432 PROTO=UDP SPT=36194 DPT=436LEN=8

	Jul 13 15:24:01 iptablesfw kernel: DROP IN=eth0 OUT= MAC=00:13:d3:38:b6:e4:00:30:48:80:4e:37:08:00 SRC=144.202.X.X DST=71.157.X.X LEN=28 TOS=0x00 PREC=0x00 
	TTL=37 ID=42032 PROTO=UDP SPT=36194 DPT=31LEN=8

## Alerts and reporting with psad

Once psad determines that a suspicious event or series of events has taken place against iptables, it alerts the administrator. By default, psad generates both email and syslog alerts.

### Psad email alerts

Email is psad’s primary alerting mechanism, because an email message can include more information than a syslog alert, and because email is ubiquitous and well-integrated with cell phones and other handheld devices. There is nearly always an easy way to check email.

#### Scan danger level, ports and flags

The first bits of information included in a psad email alert are the danger level assigned to the source address of a scan, the scanned ports, and the flags set in the scan (for TCP scans).

	Danger level: [4] (out of 5)
	Scanned tcp ports: [1-61440: 1522 packets]
	tcp flags: [SYN: 1522 packets, nmap: -sT or -sS]
	iptables chain: INPUT (prefix "DROP"), 398 packets

#### Source and destination IP address

The source IP address of the scan is next, along with reverse DNS information. By default, psad performs a reverse DNS lookup on offending source IP addresses unless the *--no-rdns* option is specified on the psad command line. Also included is a passive OS fingerprint that psad derived from the SYN packet, followed by the destination IP address and hostname.

	Source: 192.168.10.200
	DNS: int_scannerOS guess: Linux:2.5::Linux 2.5 (sometimes 2.4)
	Destination: 192.168.10.1
	DNS: iptablesfw

#### Syslog hostname, time interval and summary information

The syslog hostname is included next, and this is mostly useful if the iptables log message originates from a remote syslog server. You can configure syslog to accept log messages from multiple systems that are running iptables, and keeping track of the hostname helps to differentiate psad alerts from multiple systems. Timestamp information is also included so that you know when the psad alert was generated. Next, if ENABLE_PERSISTENCE is set to Y, the scan information will not time out or be removed from memory as psad runs. The summary information provides the time the source IP address first started behaving suspiciously, the total number of email alerts that psad has sent for the same source IP address, the complete port range that has been scanned since the source IP address attracted attention to itself, and all iptables chains and packet counts asso-ciated with the source IP address.

	Syslog hostname: iptables
	Current interval: Tue Jul 10 12:06:23 2007 (start)
	Tue Jul 10 12:06:27 2007 (end)
	Overall scan start: Tue Jul 10 12:01:23 2007
	Total email alerts: 1
	Complete tcp range: [1-65301]
	chain:   interface:   tcp:   udp:   icmp:
	INPUT    eth1         3229   0      0

#### Whois database information

The last block of information in a psad email alert is the result of a whois query against the source IP address of the scan.

### Psad syslog reporting

In addition to email alerting, syslog is an important reporting mechanism for psad. During the course of normal operations, psad generates three categories of syslog alerts.

#### Scan and signature match messages

The most important class of syslog messages informs you about scans and other suspicious traffic. These messages contain everything from source IP addresses to ports, protocols, and Snort rule matches.

#### Auto-response messages

We can respond to suspicious traffic using psad by instantiating iptables blocking rules against the IP address of the traffic source. This feature is disabled by default.

## Attack detection with Snort rules

Because the iptables logging format is so complete, psad can detect traffic that matches Snort rules that lack application layer match criteria. For exam-ple, consider the following Snort rule, which looks for TCP packets with a source port of 10101, an acknowledgment value of zero, the SYN flag set, and a TTL value in the IP header greater than 220.

	alert tcp $EXTERNAL_NET 10101 -> $HOME_NET any (msg:"SCAN myscan";
	flow:stateless; ack:0; flags:S; ttl:>220; reference:arachnids,439;
	classtype:attempted-recon; sid:613; rev:6;)

There are no tests in this Snort rule that examine application layer data, and there are about 150 such rules in the Snort ruleset. Modified versions of all of these rules are imported by psad from the */etc/psad/signatures* file. If you look at a random signature in the */etc/psad/signatures* file, such as the BAD-TRAFFIC data in TCP SYN packet signature, you can see that psad has extended the usual Snort rules syntax with some additional keywords:

	alert tcp $EXTERNAL_NET any -> $HOME_NET any (msg:"BAD-TRAFFIC data in TCP SYN
	packet"; psad_dsize:>20; flags:S; reference:url,www.cert.org/incident_notes/
	IN-99-07.html; classtype:misc-activity; sid:207; psad_id:100000; psad_dl:2;)

These keyword additions add specific information to the signature that makes the signature compatible with psad. Here are the definitions of all psad keyword additions to Snort rules:

Keyword | Used for |
---|
psad_id | This keyword defines a unique ID number so that signatures can be tracked and new signatures can be added to psad. The *psad_id* field is analogous to the Snort *sid* field. All *psad_id* values are six digits long, and they begin at 10,000 in order to distinguish them from Snort *sid* values
psad_dl | This keyword specifies the danger level that psad should assign to an IP address that triggers the signature. The *psad_dl* field accepts a value between 1 and 5
psad_dsize | This keyword specifies match criteria for the size of a packet payload by subtracting the header length from the value of the iptables LEN field. This option is analogous to the Snort *dsize* keyword, but because the LEN field of iptables log messages is the total length of the logged packet, including the IP header, psad must subtract out the header length. The *psad_dsize* keyword supports range matches of the form *n:m*, *<n*, and *>n*. For example, to test whether the payload size is greater than 1,000 bytes, you could add *psad_dsize:>1000* to a signature
psad_derived_sids | This keyword allows psad to track original Snort *sid* values from which a psad signature is derived. Some psad signatures are built up from several Snort rules, and this keyword tracks which ones
psad_ip_len | This keyword specifies match criteria for the LEN field of an iptables log message (this is similar to the *psad_dsize* keyword, but it does not subtract the length of the network and transport layer headers). Like the *psad_dsize* keyword, the *psad_ip_len* keyword also supports range matches of the form *n:m*, *<n*, and *>n*. For example, to test whether the LEN field is greater than 100 bytes but less than 200 bytes, you could add *psad_ip_len: 100:200* to a signature

#### Detecting the ipEye port scanner

The ipEye port scanner is a piece of software that allows the user to port scan a remote host. In this sense, ipEye is similar to Nmap, and it runs on Windows systems. Snort rule ID 622 detects when the ipEye scanner is being used on a network:

	alert tcp $EXTERNAL_NET any -> $HOME_NET any (msg:"SCAN ipEye SYN scan";
	flags:S;seq:1958810375; reference:arachnids,236; classtype:attempted-recon;
	sid:622; psad_id:100197; psad_dl:2;)

The above Snort rule does not require the use of any application layer tests; instead, it just detects whether the SYN flag and a specific TCP sequence number 1958810375 are set in the TCP header. To detect instances of the ipEye scanner with psad, the *--log-tcp-sequence* option must be given on the iptables command line to have iptables include TCP sequence numbers in log messages when a packet hits a LOG rule. Any iptables log message that contains the SYN flag and the sequence number 1958810375 will trigger the signature match in psad:

	Jul 11 20:28:21 iptablesfw kernel: DROP IN=eth1 OUT= MAC=00:13:46:3a:41:4b:
	00:a0:cc:28:42:5a:08:00 SRC=192.168.10.3 DST=192.168.10.1 LEN=60 TOS=0x10
	PREC=0x00 TTL=64 ID=3970 DF PROTO=TCP SPT=45664 DPT=15324
	SEQ=1958810375 ACK=0 WINDOW=5840 RES=0x00 SYN URGP=0

With psad running, the following syslog message with the words signature match appears in */var/log/messages* indicating that psad has detected the ipEye scanner:

	Jul 11 20:28:25 iptablesfw psad: src: 192.168.10.3 signature match: "SCAN ipEye SYN scan" (sid: 622) tcp port: 15324

#### Detecting the LAND attack

The LAND attack is a Denial of Service attack targeted against Windows systems, and it involves crafting a TCP SYN packet that has the same source IP address as its own destination IP address. In the Snort signature set, the key to detecting the LAND attack is the *sameip* packet header test. A modified version of Snort rule ID 527 allows psad to detect this attack in iptables logs:

	alert ip any any -> any any (msg:"BAD-TRAFFIC same SRC/DST"; sameip;
	reference:bugtraq,2666; reference:cve,1999-0016; reference:url,www.cert.org/
	advisories/CA-1997-28.html; classtype:bad-unknown; sid:527; psad_id:100103; psad_dl:2;)

Psad incorporates the *sameip* test by checking to see if the SRC and DST fields in iptables logs are identical. However, in order to reduce false positives, traffic that is logged over the loopback interface is excluded from this check. The following lines represent an iptables log message generated by the LAND attack (note the source and destination IP addresses are the same) followed by a corresponding psad syslog alert:

	Jul 11 20:31:35 iptablesfw kernel: DROP IN=eth0 OUT= MAC=00:13:d3:38:b6:e4:
	00:13:46:c2:60:44:08:00 SRC=192.168.10.3 DST=192.168.10.3 LEN=60 TOS=0x10
	PREC=0x00 TTL=63 ID=46699 DF PROTO=TCP SPT=57278 DPT=15001 WINDOW=5840 RES=0x00 SYN URGP=0

	Jul 11 20:31:38 iptables psad: src: 192.168.10.3 signature match: "BAD-TRAFFIC same SRC/DST" (sid: 527) ip

#### Detecting TCP port 0 traffic

Although legitimate TCP connections do not travel over port 0, nothing prevents someone from putting a TCP packet on the wire that is destined for port 0.

The original Snort rule ID 524 detects TCP packets that are sent to destination port 0, and there is a similar rule for UDP port 0:

	alert tcp $EXTERNAL_NET any <> $HOME_NET 0 (msg:"BAD-TRAFFIC tcp port 0
	traffic"; classtype:misc-activity; sid:524; psad_id:100101; psad_dl:2;)

An iptables log message that contains the value 0 in the DPT field will trigger this signature in psad, containing DPT=0, as shown in bold

	Jul 11 21:02:07 iptablesfw kernel: DROP IN=eth1 OUT= MAC=00:13:d3:38:b6:e4:
	00:13:46:c2:60:44:08:00 SRC=192.168.10.3 DST=192.168.10.1 LEN=44 TOS=0x00
	PREC=0x00 TTL=41 ID=43697 PROTO=TCP SPT=29121 DPT=0 WINDOW=3072 RES=0x00 SYN URGP=0

	Jul 11 21:02:11 iptablesfw psad: src: 192.168.10.3 signature match:
	"BAD-TRAFFIC tcp port 0 traffic" (sid: 524) tcp port: 0

#### Detecting zero TTL traffic

As with TCP and UDP port 0, it is possible to put a packet on the wire with a zero TTL value. Although such a packet should never be forwarded by a device that routes IP packets, a system can send such packets against any other system that is connected by means of a layer two device. Snort rule ID 1321 detects IP packets that have the TTL value set to zero, and a corresponding iptables message appears below, as shown here:

	alert ip $EXTERNAL_NET any -> $HOME_NET any (msg:"BAD-TRAFFIC 0 ttl"; ttl:0;
	reference:url,support.microsoft.com/default.aspx?scid=kb\;EN-US\;q138268;
	reference:url,www.isi.edu/in-notes/rfc1122.txt; classtype:misc-activity;
	sid:1321; psad_id:100104; psad_dl:2;)

An iptables log message that contains the value 0 in the TTL field will trigger this signature in psad, containing TTL=0, as shown in bold:

	Jul 14 15:33:28 iptables kernel: IN=eth1 OUT= MAC=00:13:46:3a:41:4b:00:13:46:
	c2:60:44:08:00 SRC=192.168.10.3 DST=192.168.10.1 LEN=104 TOS=0x00 PREC=0x00
	TTL=0 ID=0 DF PROTO=ICMP TYPE=8 CODE=0 ID=1830 SEQ=15412

	Jul 14 15:33:31 iptablesfw psad: src: 192.168.10.3 signature match: "BAD-TRAFFIC 0 ttl" (sid: 1321) ip

#### Detecting the Naptha Deial of Service attack

The Naptha Denial of Service tool is designed to flood a targeted TCP stack with so many SYN packets that the system cannot service legitimate requests. According to Snort rule ID 275, the Naptha tool creates packets that contain an IP ID value of 413, and a TCP sequence number of 6060842, as shown below:

	alert tcp $EXTERNAL_NET any <> $HOME_NET any (msg:"DOS NAPTHA"; flags:S;
	id:413; seq:6060842; reference:bugtraq,2022; reference:cve,2000-1039;
	reference:url,razor.bindview.com/publish/advisories/adv_NAPTHA.html;
	reference:url,www.cert.org/advisories/CA-2000-21.html
	reference:url,www.microsoft.com/technet/security/bulletin/MS00-091.mspx;
	classtype:attempted-dos; sid:275; psad_id:100111; psad_dl:2;)

The following iptables log message triggers the Naptha rule in psad (notice the IP ID value of 413, the TCP sequence number of 6060842 and the SYN flag set):

	Jul 11 20:28:21 iptablesfw kernel: DROP IN=eth1 OUT= MAC=00:13:46:3a:41:4b:
	00:a0:cc:28:42:5a:08:00 SRC=192.168.10.3 DST=192.168.10.1 LEN=60 TOS=0x10
	PREC=0x00 TTL=64 ID=413 DF PROTO=TCP SPT=45664 DPT=15304
	SEQ=6060842 ACK=0 WINDOW=5840 RES=0x00 SYN URGP=0

	Jul 14 15:35:26 iptablesfw psad: src: 192.168.10.3 signature match: "DOS NAPTHA" (sid: 275) tcp port: 15304

#### Detecting source routing attempts

Source routing is a technique supported by the IPv4 protocol by which an adversary can attempt to route packets through networks that would otherwise be inaccessible. Source routing options are included within the options portion of the IP header, and Snort rule ID 500 detects loose source routing attempts with the *ipopts* IP header test:

	alert ip $EXTERNAL_NET any -> $HOME_NET any (msg:"MISC source route lssr";
	ipopts:lsrr; reference:arachnids,418; reference:bugtraq,646; reference:cve,
	1999-0909; classtype:bad-unknown; sid:500; psad_id:100199; psad_dl:2;);

Because it is only possible to issue loose source routing directives when using IP options, psad can only detect this type of traffic if the LOG rule is built within the *--log-ip-options* command-line argument to iptables. When iptables logs an IP packet that contains IP options, the log message includes the options as an argument to the OPT string like OPT (830708C0A80A0300). According to RFC 791, the loose source routing option is defined as option number 131 (hex 83) and has a variable length. The following iptables log message contains an OPT string generated by an IP packet that contains the loose source routing option (note that after OPT there is the number 83):

	Jul 13 19:39:53 iptablesfw kernel: IN=eth1 OUT= SRC=192.168.10.3
	DST=192.168.10.1 LEN=48 TOS=0x00 PREC=0x00 TTL=64 ID=10096 OPT
	(830708C0A80A0300) PROTO=TCP SPT=3017 DPT=0 WINDOW=512 RES=0x00 URGP=0

Psad notices the source routing attempt:

	Jul 13 19:39:56 iptablesfw psad: src: 192.168.10.3 signature match: "MISC source route lssr" (sid: 500) ip

#### Detecting Windows Messenger pop-up spam

One common way that spammers try to have their spam viewed by more people is by sending it directly through the Windows Messenger service. Although it is pretty useless to detect this traffic when it’s coming from external networks (because each spam message can be spoofed and only a single UDP packet is required to transmit it unless the message is large), it can be important to detect it when it’s coming from your internal network. Any system that is generating such traffic on your intranet may have been compromised and used to send spam by someone controlling the system from afar.

Because psad treats packets that are logged in the INPUT chain as having been directed at the home network (regardless of whether they come from internal addresses), the following signature detects Windows pop-up spam attempts when they are directed at the firewall (note the UDP with a destination port range from 1026 to 1029 and an application layer data size greater than 100 bytes with the *psad_dsize* test):

	alert udp $EXTERNAL_NET any -> $HOME_NET 1026:1029 (msg:"MISC Windows
	popup spam attempt"; classtype:misc-activity;
	reference:url,www.linklogger.com/UDP1026.htm; psad_dsize:>100; psad_id:100196; psad_dl:2;)

The log message shows how iptables sees a pop-up spam message attempt (note that the destination port is 1026 and the size of the UDP packet, including the 8-byte UDP header, is 516 bytes):

	Jul 14 15:03:24 iptablesfw kernel: DROP IN=eth0 OUT= MAC=00:13:d3:38:b6:e4:
	00:90:1a:a0:1c:ec:08:00 SRC=65.182.197.125 DST=71.157.X.X LEN=536 TOS=0x00
	PREC=0x00 TTL=117 ID=6090 PROTO=UDP SPT=3515 DPT=1026 LEN=516

Psad notices the traffic and generates a syslog alert:

	Jul 14 15:03:29 iptablesfw psad: src: 65.182.197.125 signature match: "MISC Windows popup spam attempt" (sid: 100196) udp port: 1026

## OS fingerprinting

There are several techniques for remotely fingerprinting operating systems via network traffic. They can be divided broadly into two categories: active and passive.

### Active OS fingerprinting with nmap

Nmap’s *-O* option is probably the best-known active OS fingerprinting implementation. Nmap primarily utilizes the vagaries of TCP to guess the identity of remote operating systems, especially these:

* The way a target stack constructs the options portion of the TCP header in response to SYN packets sent by Nmap.
* The nature of ICMP Port Unreachable messages elicited from a targeted system after sending a UDP packet to a closed port. While operating systems are supposed to return a portion of the original UDP packet sent to a closed UDP port within an ICMP Port Unreachable message, many stacks out there do not perform this flawlessly; things such as checksums, IP ID values, and the IP total length field can become garbled. The extent and manner in which these values become garbled is used as a measure to assist in fingerprinting the remote stack.

### Passive OS fingerprinting with p0f

Given psad’s propensity for passive detection versus actively generating network traffic, active OS fingerprinting is not used. One of the most well-known and successful passive operating system fingerprinting implementations is p0*. As it turns out, if you can passively intercept raw TCP packet data, either because you have access to a network segment over which packets are flowing or because packets are directed at or originate from a system that you control, you can glean a lot of interesting information that is useful for OS fingerprinting. TCP SYN and SYN/ACK packets contribute the most information, because they define the parameters under which TCP connections are supposed to behave and because different TCP stacks negotiate these parameters with some distinction. In the p0f incarnation of OS fingerprinting, a remote operating system is identified by examining several fields within the IP and TCP headers of TCP SYN or SYN/ACK packets that originate from the system. These fields include the following:

* Fragmentation bit
* Initial TTL value
* Maximum Segment Size (MSS)
* Overall SYN packet size
* TCP option values and order
* TCP window size

p0f uses a custom signature format to store the specific parameters mentioned above for each OS. For example, here’s a fingerprint for a Linux system:

	S3:64:1:60:M*,S,T,N,W1:.:Linux:2.5 (sometimes 2.4) (1)

The p0f signature format has several fields separated by colon (:) characters:

* Reading from left to right, the first field, S3, refers to the TCP window size. This field instructs p0f to look for TCP SYN packets with a window size that is a multiple of three times the value of the Maximum Segment Size (MSS).
* The second field, 64, refers to the TTL value in the IP header; in this case a TTL of 64. Because TTL values are decremented as packets traverse the Internet, this field refers to the initial TTL value, and p0f allows the actual TTL value in the packet to be significantly less.
* The third field, 1, refers to the Don’t Fragment (DF) bit in the IP header. Because the signature has the value 1 in this field, it is looking for the DF bit to be set.
* The fourth field, 60, is the overall packet size. In this example, the sig-nature requires the size to be 60 bytes. 
* The fifth field, S,T,N,W1, describes the options portion of the TCP header. In this example, the signature is looking for any MSS, followed by the Selective Acknowledgment (S), Timestamp (T), NOP (N), and Window Scaling Factor (W1) options. 

#### Emulating p0f with psad

In order to run its fingerprinting algorithm over packet headers, p0f uses libpcap to sniff packets directly off the wire. By contrast, psad contains code that implements OS fingerprinting based around p0f signatures but only requires iptables log messages as the data input. This is possible because every header value examined by p0f (TCP window size, TTL value, TCP options, and so on) is also available in iptables log messages as long as the *--log-tcp-options* argument is used to build the LOG rule.

	Jul 14 22:03:42 iptablesfw kernel: DROP IN=eth1 OUT= MAC=00:13:46:3a:41:4b:
	00:a0:cc:28:42:5a:08:00 SRC=192.168.10.3 DST=192.168.10.1 LEN=60 TOS=0x10
	PREC=0x00 TTL=64 ID=37356 DF PROTO=TCP SPT=54423 DPT=23 WINDOW=5840 RES=0x00
	SYN URGP=0 OPT (020405B40402080A0B00CE790000000001030302)

#### Detecting TCP options from iptables logs

The only tricky part to implementing p0f OS fingerprinting with log messages like the one shown above is that the long OPT hex dump has to be decoded in order to match up against a p0f signature. The OPT string represents a hex dump of the TCP options portion of the TCP header, and by examining this string one byte at a time and matching it against the set of possible options values in the TCP header, the options used in a SYN packet become clear. Except for the End of Option List and No Operation (NOP) options which are each only one byte wide, every option is designated by a type, is followed by the length, and ends with the value. This is called *Type-Length-Value (TLV) encoding*.

For example, the beginning of the hex string above, 020405B4, decodes as 02 = Maximum Segment Size, 04 = Length (including the type byte), 05B4 = 1460 (decimal value). Continuing this analysis similarly for the entire hex dump yields the following:

* Maximum Segment Size is 1460
* NOP
* Selective Acknowledgment is OK
* Timestamp is 188338970
* Window Scaling Factor is 2

This set of options matches the p0f fingerprint S4:64:1:60:M*,S,T,N,W2: Linux:2.5::Linux 2.5 (sometimes 2.4).

By matching the TCP options in SYN packets against p0f signatures, psad can often identify the specific remote operating system that is poking at your iptables firewall. This functionality is only made possible, however, through the use of the *--log-tcp-options argument*.

## Active response with psad

One feature that is commonly sought after in intrusion detection systems is the ability to automatically respond to an attack. Such responses for network traffic can take many forms against an attacker’s perceived IP address, including the instantiation of firewall blocking rules, modification of routing tables, generation of ICMP port/host unreachable packets for UDP attacks, and use of TCP resets for attacks that take place over TCP connections.

## Intrusion prevention vs active response

In today’s varied world of computer security products, techniques, and solutions, the term *intrusion prevention* has received widespread attention. Much of this attention probably stems from the perhaps overly powerful implications of the term, but this is not to say that the concept of proactively preventing security compromises is without merit. Intrusion protection techniques range from host level stack-hardening mechanisms  inline network devices with software that can prevent malicious packets from ever reaching their intended targets, while simultaneously allowing all other traffic through unimpeded. In contrast, *active response* refers to the set of mechanisms that can be employed against an attacker (once an attack is detected) that do not necessarily thwart the attack. The fact that active response isn’t always able to prevent the initial attack is an important distinction, and it solidly delineates the difference between intrusion prevention and active response.

## Active response trade-offs

Automatically responding to an attack by generating session-busting traffic or modifying a firewall policy is not without consequences. An attacker may quickly notice that TCP sessions with the target system are being torn down or that all connectivity with the target has been severed. The most logical conclusion to draw would be that an active response mechanism of some type has been deployed to protect the target. If the active response system has been configured to respond to relatively innocuous traffic such as port scans or port sweeps, it becomes exceedingly easy for an attacker to abuse the response mechanism and turn it against the target.

#### Classes of attacks

Many pieces of software that offer active response capabilities (including psad) offer the ability to *whitelist* specific hosts or networks so that even if an attacker were to spoof port scans or other malicious traffic from these networks, the response mechanism would take no action.

A better strategy for responding to attacks is to enable the response mechanism to respond only to attacks that require bidirectional communication between the attacker and the target. Generally, this implies that the attacker has established a TCP connection and is using it to deliver an attack.

Detecting attacks in an established TCP connection requires that the detection system maintain a table of established connections and look for attacks within these connections. TCP packets with realistic-looking sequence and acknowledgment numbers can be spoofed after all, but such packets are not part of any truly established connection, and it is up to the detection mechanism to determine this. 

#### False positives

All intrusion detection systems have some propensity for generating *false positives* — alerts that misidentify activity as being malicious. *False negatives*, or the failure to generate an event when real malicious traffic exists, are also relatively commonplace. False positives can be minimized through careful tuning, but there will always be a chance they will occur; hence, automatically responding to traffic that is incorrectly judged as being malicious is not good for maintaining general network connectivity. Still, many security administrators make the judgment that some types of events, even if generated from misidentified activities, are potentially damaging enough to warrant a draconian response.

## Responding to attacks with psad

The main method psad employs to respond to an attack is the dynamic reconfiguration of the local filtering policy so that it blocks all access from an attacker’s source IP address for a configurable amount of time.

The ability to dynamically reconfigure the local iptables policy implies that the response takes place at the network layer; for example, an attacker’s IP address is blocked from talking up through the IP stack. If an attacker has an established TCP session with any server in the local network when a blocking rule is instantiated, then (because there is no TCP reset generated along with the blocking rule) all TCP packets will be dropped, and the endpoint TCP stacks will attempt to retransmit data until they timeout.

#### Features

The following active response features are supported by psad:

* Configurable minimum danger level an attacker must reach before an iptables blocking rule is added
* The ability to make blocking rules either permanent or temporary, based on a configurable time-out
* The use of separate iptables chains for all blocking rules so as to not interfere with any existing iptables policy on the local system
* The preservation of blocking rules across restarts of psad or even system reboots
* The inclusion of status output for all currently blocked IP addresses, along with the remaining number of seconds before the associated iptables rules are removed
* The ability to have an external process instruct psad to add or remove a blocking rule against a specific IP address by using the *--fw-block-ip* and *--fw-rm-block-ip* command-line arguments, respectively
* The ability to differentiate between port scans and attacks that trigger a signature match, and the addition of a blocking rule in iptables that can be tied to either one
* Email notifications when an IP address is added or deleted from the psad blocking chains

#### Configuration variables

The most important variable that controls whether or not psad enters into active response mode is ENABLE_AUTO_IDS, which can be set to either Y or N within the */etc/psad/psad.conf* file. When this feature is enabled, several other variables control various operational aspects of psad as it endeavors to automatically block attackers.

The AUTO_IDS_DANGER_LEVEL variable sets a threshold from 1 to 5 for the minimum danger level that an IP address must reach before a blocking rule is instantiated. By tuning the port scan thresholds, individual signature danger levels (see */etc/psad/signatures*), and automatic danger level assignments (see */etc/psad/auto_dl*), psad can be made to perform granular decisions about whether or not to automatically block an IP address.

The AUTO_BLOCK_TIMEOUT variable defines the length of time (in seconds) that an iptables blocking rule remains in effect. The default value is 3,600 seconds, or one hour. By setting AUTO_BLOCK_TIMEOUT to zero, all blocking rules are made permanent and are only removed if psad is restarted or the system is rebooted, unless FLUSH_IPT_AT_INIT is disabled.

The IPTABLES_BLOCK_METHOD and TCPWRAPPERS_BLOCK_METHOD variables control whether psad uses iptables or tcpwrappers to block offending IP addresses. If psad is configured to respond to attacks, then the recommended setting is to enable iptables blocking.

The ENABLE_AUTO_IDS_REGEX and AUTO_BLOCK_REGEX variables allow the act of adding a blocking rule against an IP address to be tied to whether or not a logging prefix matches a particular regular expression. This is most useful for blocking IP addresses, but only after monitoring an attack that requires bidirectional communication through an established TCP session. Because port scans are easily spoofed, this feature provides a powerful mechanism to restrict blocking rules to IP addresses that are not simply spoofed by an attacker.

Finally, the remaining important configuration variables for automatically blocking attackers control the manner in which iptables rules are created. These variables all begin with the string IPT_AUTO_CHAIN followed by an integer (just like the DANGER_LEVEL{n} variables), and they specify seven criteria to influence how psad adds rules to iptables:

* The iptables target for the rule (e.g., DROP)
* Whether to apply the rule to the source or the destination (or both)
* The table in which the rule is added (e.g., the filter table
* The iptables chain to which a jump rule is added for the custom psad chain
* The position within this iptables chain where the jump rule is added
* The name of the custom psad chain
* The position within the custom psad chain where new rules are added

Psad maintains the creation and maintenance of not only the blocking rules themselves, but also the custom psad chains and the jump rules into these chains from the built-in iptables chains.

The default IPT_AUTO_CHAIN{n} variables instruct psad to add a total of four blocking rules for an IP address that trips the AUTO_IDS_DANGER_LEVELthreshold:

* A DROP rule against the offending IP address in the PSAD_BLOCK_INPUT chain that forces packets to jump to this chain, so that packets from the attacker that are destined for the local system never communicate with a local socket.
* A DROP rule against the offending IP address in the PSAD_BLOCK_OUTPUT chain, so that packets originating from the local system never make it back to the attacker.
* Two DROP rules against the offending IP address in the PSAD_BLOCK_FORWARD chain that restrict packets originating from or destined for the offending IP address. This way, if the iptables firewall protects a system on an internal network, no attacker is able to connect with that system.

For reference, the default IPT_AUTO_CHAIN{n} variables in the */etc/psad/psad.conf* file appear below:

	IPT_AUTO_CHAIN1   DROP, src, filter, INPUT, 1, PSAD_BLOCK_INPUT, 1;
	IPT_AUTO_CHAIN2   DROP, dst, filter, OUTPUT, 1, PSAD_BLOCK_OUTPUT, 1;
	IPT_AUTO_CHAIN3   DROP, both, filter, FORWARD, 1, PSAD_BLOCK_FORWARD1, 1;

## Translating Snort rules into iptables rules

*Fwsnort* or *Firewall Snort* is a software that translates Snort rules into equivalent iptables rules. The fwsnort project utilizes the filtering and inspection capabilities of iptables — including heavy use of the iptables string match extension — in order to match Snort rules as closely as possible within an iptables ruleset.

Snort is typically deployed in a passive stance and used to monitor a network for suspicious activity — it is not usually deployed inline, although it does offer this capability. Any policy built by fwsnort is not constrained to passive packet inspection — an fwsnort policy can be configured to drop malicious packets via the iptables DROP target.

## Why run fwsnort?

The fwsnort project is focused on enhancing the ability of the Linux kernel to control the types of packets allowed to communicate with (or through) your Linux system. By combining the power of the Snort signature language with the speed of the Linux kernel and the simplicity of iptables commands, fwsnort is able to bolster the security stance of an existing IDS/IPS infrastructure. Deploying fwsnort alongside another IDS/IPS is straightforward, since fwsnort simply builds a shell script to execute iptables commands (typically on an end host). In addition, because iptables is always inline to network traffic, it is rigorously tested for stability and speed.

#### Defense in depth

Intrusion detection systems themselves can be targeted with attacks ranging from efforts to subvert the IDS alerting mechanism by forcing false positives to be generated, to attempts to gain outright code execution by exploiting a vulnerability within the IDS. For example, both real and faked attacks can be sent over the Tor network in order to make the attacks appear to originate from IP addresses that are not associated with the attacker’s network. The defense-in-depth principle applies not only to conventional computer systems, but also to security infrastructure systems such as firewalls and intrusion detection systems. Hence, there is room to supplement existing intrusion detection/prevention systems with additional mechanisms.

#### Target-based Intrusion Detection and network layer defragmentation

Building features into an IDS that allow it to augment detection operations with characteristics of end hosts is known as *target-based intrusion detection*. For example, the Snort IDS offers network layer defragmentation via the *frag3* preprocessor, which can apply various packet defragmentation algorithms to fragmented network traffic. The *frag3* preprocessor does not automatically map defragmentation algorithms to hosts; instead, you must manually tell Snort which algorithm to run for each monitored host or network, and therein lies the possibility of configuration errors.

In the case of fwsnort, we don’t need to worry about fragmentation issues because the defragmentation algorithm applied is the algorithm of the actual victim IP stack.

#### Lightweight footprint

Heavily used systems may lack available resources to deploy an additional userland process for intrusion detection (such as Snort). In the case of fwsnort, packet inspection takes place directly within the Linux kernel, and so this usually places a lightweight usage footprint on system resources — there is no need to copy data from kernel memory into a userland process. On systems where it is inappropriate to deploy a dedicated IDS/IPS because of resource constraints, fwsnort may provide a tenable alternative.

## The fwsnort interpretation of snort rules

Not every Snort rule can be translated, because of limitations in facilities provided by iptables versus those provided by Snort.

### Translating the snort rule header

Snort rules are split into two major sections: the rule header and the rule options. The rule header strictly defines match criteria at the network and transport layers; no application layer matching criteria can be placed within the Snort rule header.

#### Snort rule header

For example, a Snort rule header that instructs Snort to match all TCP traffic from any source address to port 53 on any IP address within the 192.168.10.0/24 subnet looks like :

	alert tcp any any -> 192.168.10.0/24 53

From a signature perspective, this header is roughly equivalent to the following iptables command:

	[iptablesfw]# iptables -A FORWARD -p tcp -d 192.168.10.0/24 --dport 53 -j LOG

First, Snort supports IP, ARP, UDP, ICMP, and TCP within the rule header directly. Next, the address portion of the Snort rule header allows Snort rules to apply to specific networks or individual IP addresses. Networks can be specified in CIDR notation (e.g., 192.168.10.0/24) or in standard dotted-quad notation (e.g., 192.168.10.0/255.255.255). Lastly, transport layer source and destination port numbers are defined. A range of ports can be specified with the colon (:) character (e.g., 21:23 would apply to ports 21 through 23), and port numbers can also be negated with the exclamation point (!) character (e.g., !80 would apply to all ports except port 80).

#### Rule actions and iptables emulation

Rule actions can be either *alert*, *log*, *pass*, *activate*, or *dynamic*, though Snort rules generally default to *alert*. The *alert* action is the most important - it tells Snort to generate an event and then log the packet that caused the alert. The remaining actions provide additional functionality, such as passing the packet without taking any action (*pass*), logging the packet (*log*), or setting up certain rules so that they remain dormant until a particular rule is matched, at which point they become active and log the traffic (*activate* and *dynamic*). So far, everything but the *activate* and *dynamic* actions in the Snort rule header is supported by analogous functionality in iptables and fwsnort. Source and destination IP addresses or networks can be specified to iptables with the *-s IP* and *-d IP* arguments, respectively, and both CIDR and dotted-quad network notations are also supported. Source and destination port numbers can be given with the *--sport port* and *--dport port* options, and as with Snort, port ranges are specified with the colon (:) character. The protocol can be given with *-p protocol*. For example, to build an iptables rule that applies to TCP traffic, you would use the *-p tcp* argument to the iptables command. To restrict the rule to destination port 53, you would use *--dport 53*. To apply the rule to the destination of any IP address in the 192.168.10.0/24 subnet, you would use *-d 192.168.10.0/24*.

#### Snort action and alerting

Snort provides several excellent options for generating alerts and logging packet data; fortunately, iptables can emulate a significant fraction of these capabilities. With fwsnort, we combine these abilities to emulate the following Snort actions:

* **alert:** This is the main Snort rule action, and within fwsnort it is equated with the usage of the iptables LOG target to log Snort signature *msg* fields within the log prefix and packet header information in the remainder of the log message. Within iptables, we don’t have the ability to log application layer data (unless the ULOG target is used along with ulogd PCAP writer), but at least the attacks are logged via the *msg* field.
* **log:** Within fwsnort, this action is equated with the iptables ULOG target, where the ulogd PCAP writer is used for more comprehensive packet logging.
* **pass:** This action is sometimes used in Snort rulesets to ignore packets, and is equated with the usage of the iptables ACCEPT target by fwsnort. The ACCEPT target allows matching traffic to pass without any modifications or further action taken by iptables.

The *activate* and *dynamic* actions are not yet supported by fwsnort, but this is not because of a limitation in iptables; it would significantly complicate both the iptables policy and the script required to build it, because a separate chain would have to be constructed for each *dynamic* rule.

### Translating snort rule options: iptables packet logging

Snort’s complex packet processing is mostly driven by rule options. Snort depends on these options to define what constitutes an attack or other activity worthy of sending an alert to the administrator, and the number of available options has expanded to meet the demands of an ever-changing exploit landscape.

The iptables LOG target allows us to generate detailed logs of packet header information when packets trigger a logging rule. Although iptables can match and filter packets based upon most of the important fields in its logs (such as source and destination IP addresses, Internet protocol, and transport layer port numbers), some fields within the network and transport layer headers cannot be used as a match criteria.

Any Snort rule that uses such an option (i.e., an option that is logged by iptables but cannot be used as a match criteria) requires a userland application to parse the logging message in order to detect attacks described by such a rule. Consequently, for attacks matching these Snort rules, iptables cannot itself take any action against them — only a userland application can take action after parsing the attack out of the iptables log messages. Therefore, fwsnort does not translate Snort rules that contain options in the following list, because there are no equivalent iptables matching/filtering options:

* **ack:** Matches the 32-bit acknowledgment number in the TCP header
* **icmp_id:** Matches the ID value present in some ICMP packets
* **icmp_seq:** Matches the sequence value present in some ICMP packets
* **id:** Matches the 16-bit IP ID field in the IP header
* **sameip:** Searches for identical source and destination IP addresses
* **seq:** Matches the 32-bit sequence number in the TCP header
* **window:** Matches the 16-bit window value in the TCP header

### Snort options and iptables packet filtering

So far, we have discussed those Snort rule options for which there is only logging support in iptables. Now we’ll look at Snort rule options for which iptables also provides both explicit matching and filtering support. Snort rules that use these options can be translated into equivalent iptables rules, and any of the standard iptables targets (DROP, LOG, REJECT, and so on) can be applied to a matching packet. Snort rule options that fall into this category include:

Option | Used for |
---|
content | The *content* option in the Snort rules language requires an argument in the form of a sequence of bytes, say */bin/sh*, and Snort uses the Boyer-Moore string search algorithm to search application layer data for these bytes. The iptables string match extension uses an in-kernel implementation of the same algorithm (selected by the user) to also search for sequences of bytes within the application payload of packets as they enter into the networking stack. Given the string */bin/sh* in a content option within a Snort rule, the equivalent iptables arguments are *-m string --string --algo bm "/bin/sh"*. 
uricontent | The *uricontent* Snort option enables Snort to handle URL-encoded application data that is transferred over HTTP. An attack against a webserver that supports URL-encoded data can take any form that it wishes within the constraints of the encoding scheme, and the result is that an attack can exhibit a degree of variability on the wire that can be difficult to decode without a way to normalize the data. For example, the string */bin/sh* and its URL-encoded equivalent *%2f%62%69%6e%2f%73%68* are absolutely identical in the eyes of a webserver after the decoding process, and yet these raw byte sequences look completely different on the wire. Strictly speaking, there is no direct translation for the uricontent Snort option within iptables, because the string match extension cannot decode URL-encoded data directly. While the encoded string *%2f%62%69%6e%2f%73%68* can be included by fwsnort within a separate rule, an attacker can sidestep this just by mixing the encoding — for example, the attacker could send */bin2f%73%68*. The number of possible encodings for a string n characters long quickly gets large as nincreases. However, at the same time, there is no requirement on the part of an attacker to URL-encode an attack at all, and seeing the string */bin/sh* in the HTTP stream is suspicious — whether it is encoded or not. In addition, certain automated attacks may not include the ability to change the encoding of a portion of an exploit sent against a webserver, so a single string is all that is needed to detect the attack. Thus, fwsnort equates the *content* and *uricontent* Snort options, although clearly this comes at the expense of potentially missing URL-encoded attacks.
offset | The *offset* Snort option instructs Snort to begin application content matching operations at a specified number of bytes past the beginning of the payload data within a packet. This is an absolute number that applies to all content matches in the Snort rule, and it is not subject to the relative number of bytes between multiple content matches (the *distance* Snort option is used for this). The *offset* option is supported in iptables by using the *--from* command-line argument to the string match extension when looking for a pattern in payload data.
depth | The *depth* Snort option requires that all attempts to match content within packet payload data do not exceed a specified number of bytes beyond the beginning of the payload. Like the *offset* option above, using the *depth* criteria within a Snort rule applies globally to all content matches. To search for patterns that cannot be more than a given number of bytes apart, one would use the *within* Snort rule option. The *--to* command-line argument to the string match extension is used to emulate the *depth* option within iptables. 
distance | The *distance* option is used by Snort to specify the number of bytes to skip between pattern matches. There is no direct way to tell the string match extension how many bytes to skip from a previous pattern match, but fwsnort uses an approximation based on the length of the previous pattern match and any offset modifier. To disable the translation of Snort rules that contain the *distance* keyword, you can use the *--strict* option on the fwsnort command line.
within | The *within* option instructs Snort to require that a subsequent pattern match after an initial match must take place within a specified number of bytes. This is similar to the *distance* option and is supported in fwsnort by making an approximation based on the length of the previous pattern (*--strict* on the fwsnort command line disables this behavior).
flags | The *flags* Snort option applies a search criteria to the control bits in the TCP header. The control bits vary depending on the state of a TCP connection, and iptables can match specific combinations via the *--tcp-flags* argument. For example, the Snort rule to detect an Nmap OS fingerprint attempt uses the flags option to search for the Syn, Fin, Push, and Urg flags in the TCP header. The equivalent arguments to the iptables binary are *-p tcp --tcp-flags SYN, FIN,PSH,URG SYN,FIN,PSH,URG*. The *--tcp-flags* command-line switch requires two arguments: a list of the flags that should be inspected, followed by a list of those flags that must actually be set. This allows the first argument to act as a mask for the set flag bits that must be examined. No special kernel configuration option is required to make use of the *--tcp-flags* option, because it is built in to the core TCP-handling code within iptables.
itype and icode | Both the *itype* and *icode* options match specified numeric values within the 8-bit ICMP type and code fields, respectively, of the ICMP header. For example, to test for ICMP fragmentation-needed packets within a Snort rule, we would use the options *itype: 3; icode: 4;*. The specific numeric values that map to the various ICMP types and codes are defined in RFC 792. The iptables ICMP-handling code supports matching against the type and code fields within the ICMP header via the arguments *-p icmp --icmp-type type/code*, where *type/code* is the proper ICMP message type spelled out (i.e., *source-quench*) or its equivalent numeric value. A complete list of all ICMP message types supported by iptables can be obtained by executing *# iptables -p icmp -h*, and their corresponding numeric values can be found within the *icmp_codes[]* array in the extensions/libipt_icmp.c file within the iptables sources. Both the Snort *itype* and *icode* options support ranges of ICMP types and codes through the use of the *<* and *>* operators. For example, to match against all ICMP messages that have a type greater than 10 and code less than 30, one would use *itype: >10; icode: <30;* within a Snort rule. Unfortunately, the iptables ICMP match does not allow the notion of ranges for the ICMP type or code fields, but it should be noted that no default Snort rules use an *itype* range, and less than one percent use an *icode* range.
ttl | The *ttl* option allows Snort to match against the Time-to-Live (TTL) value in the IP header. The *ttl* option is quite flexible and allows the TTL header value to be compared against a specified integer value where the supported comparisons are *less than*, *equal to*, or *greater than*. For example, to match a TTL value in the IP header that is exactly 30, the Snort rule option *ttl:30;* would be given. To match only if the TTL value is less than 30, the option *ttl:<30;* would suffice, and finally, to match only if the TTL value is greater than 30, we would include *ttl:>30;*. These operations are supported by iptables with its TTL match via the arguments: *-m ttl --ttl-lt value*, *-m ttl --ttl-eq value*, and *-m ttl --ttl-gt value*. The iptables TTL match is only available if CONFIG_IP_NF_MATCH_TTL is enabled within the kernel configuration file.
tos | The *tos* option instructs Snort to inspect the Type Of Service (TOS) bits within the IP header, and this option is relatively simple in Snort since it can only accept a numeric value with an optional ! to negate it. This option is supported by the iptables TOS match with the arguments *-m tos --tos value*. The TOS match also supports negation.
ipopts | The *ipopts* Snort option allows searching criteria to be applied to the options portion of the IP header.
dsize |
ip_proto |
flow |
replace |
resp |

### Unsupported snort rule options

There are many options in Snort for which there is no good iptables equivalent. Unsupported options include the following:

Option | Used for |
---|
asn1 | The *asn1* keyword allows Snort to link signatures to decoded Abstract Syntax Notation One (ASN.1) data (commonly used in SMB protocols). There is no good way to emulate the complex processing associated with this Snort keyword in iptables.
byte_jump | The *byte_jump* option allows packet data itself to determine how many bytes of data Snort will skip over before applying the next pattern match or *byte_test*. This means that offsets do not have to be known a priori, and therefore the protocol itself can dictate where the subsequent test is performed. This is especially useful for protocols that use fields that vary in length (such as DNS). Just as for the *byte_test* keyword above, using the u32 match is the best way to emulate the *byte_jump* test with iptables, but we’ll have to wait until the u32 match is available in the 2.6 kernel.
byte_test | This option gives Snort the ability to apply numeric tests to particular offsets within packet data. Although the *pcre* option can be used to emulate some of the functionality provided by *byte_test*, this should normally be avoided, because *byte_test* will generally outperform *pcre* for such operations. The u32 match can also be used to emulate this to some degree, but it is not yet available for the 2.6 kernel.
flowbits | This option is used by Snort to communicate state information between rules. For example, an initial Snort rule might detect whether the login stage of a cleartext protocol has completed, and if so, set a tag *LoggedIn* via the *flowbits* option. Then a completely different Snort rule could also use the *flowbits* option to test whether the *LoggedIn* tag has been set before performing an additional signature test on the packet data. This type of operation can be emulated to a limited extent by combining the CONNMARK target in iptables with the string match extension, but this is not yet supported by fwsnort. 
fragbits | This option allows Snort to perform tests against the fragmentation bits in the IP header. Although iptables can apply match criteria to determine whether a packet has been fragmented (via the *-f* argument), this capability is not nearly as powerful as the Snort implementation. In addition, if connection tracking is enabled in the Linux kernel, packets are automatically defragmented before iptables sees them. This is a requirement for connection tracking to work, because only complete packets can be classified as either belonging to a connection or not. This is an advantage in the sense that networks protected by such kernels automatically stop most IDS evasion attempts that rely on fragmented packets.
isdataat | This option instructs Snort to test simply whether data exists at a particular offset. The offset may be specified in absolute terms (e.g., 30) or may be derived from a previous pattern match (e.g., 30,relative).
pcre | This stands for *Perl Compatible Regular Expression* and allows Snort to apply complex regular expressions (that may include back references and other intensive operations) to packet data. Putting this functionality directly into the Linux kernel is risky from a stability standpoint; it makes more sense to perform these sorts of operations in a userland application.
rpc | This allows Snort to decode the application, procedure, and program version contained within Remote Procedure Call (RPC) traffic. The iptables *rpc* extension allows procedure call numbers to be matched within an iptables policy, but this module is only available for pre-2.6 kernels and is not yet supported by fwsnort.
